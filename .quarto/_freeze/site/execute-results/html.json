{
  "hash": "4cd2b9d6846b826034a4a3fe32400d41",
  "result": {
    "markdown": "---\ntitle: \"Comparison of networks inferred by DIANE and TDCor\"\nformat:\n  html:\n    page-layout: full\n---\n\n\nThis document presents the comparative network tools inferred by DIANE and TDCor and their use, offering detailed explanations on the interpretation of the results provided by the functions implemented in R. The results encompass several metrics allowing an in-depth evaluation of the performance of the two methods. network inferences. This is a first step to enlighten users on the respective strengths and limitations of the two methods.\n\n# Metrics\n\n* Distribution of node degrees\n* Percentage of overall identity of the graph at degree 1 (i.e. percentage of common edges in each of the graphs compared by just looking at the nodes 2 by 2), with each time the percentage identity by taking the graph from TDCor or DIANE as reference\n* Comparison of degree of nodes versus percentage identity on the neighborhood of these nodes at degree 1 (i.e. percentage of common neighbors between the graphs compared) for each node of the analyzed graph  \n* Percentage of overall identity of the graph at degree 2, 3, or even n (i.e. percentage of common paths in each of the graphs compared by looking at 2, 3 or n nodes of distance), with each time the percentage of identity by taking the graph from TDCor or DIANE as a reference\n* Analysis of the directness/time delay indices of the edges predicted by TDCor and common with those predicted by DIANE\n* Analysis of common clusters ?\n\n# R functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSort_Columns <- function(data) {\n  \n  # create a new dataframe with sorted gene pairs\n  data_sorted <- data.frame(from = pmin(data$from, data$to), to = pmax(data$from, data$to))\n  \n  # remove duplicate rows\n  data_sorted <- unique(data_sorted)\n  \n  # return the sorted dataframe\n  return(data_sorted)\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDataframe_To_Graph <- function(data){\n  # sort gene pairs in both datasets\n  data <- Sort_Columns(data)\n  \n  # concatenate gene pairs into a new dataframe for each dataset\n  gene_pairs <- cbind(from = data$from, to = data$to, pairs = paste(data$from, data$to, sep = \"_\"))\n  \n  # remove duplicates in gene pairs\n  unique_pairs <- unique(gene_pairs)\n  \n  # load required libraries\n  library(tidyr)\n  library(igraph)\n  \n  # create graph object from dataframe\n  graph <- graph_from_data_frame(unique_pairs, directed=FALSE)\n  \n  # return the dataframe with the results\n  return(graph)\n}\n```\n:::\n\n\n## Distribution of node degrees\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDegree_Distribution <- function(data) {\n  \n  # concatenate gene pairs into a new dataframe and remove duplicates in gene pairs\n  unique_pairs <- Sort_Columns(data)\n  \n  # initialize a vector to store counts\n  all_genes <- c(unique_pairs[,1], unique_pairs[,2])\n  unique_genes <- unique(all_genes)\n  counts <- numeric(length(unique_genes))\n  \n  # loop through genes\n  for (i in seq_along(unique_genes)) {\n    gene <- unique_genes[i]\n    # count the number of associated genes in both columns\n    count <- sum(unique_pairs[,1]==gene) + sum(unique_pairs[,2]==gene)\n    counts[i] <- count\n  }\n  \n  # create a dataframe with the results\n  result <- data.frame(gene=unique_genes, degree=counts)\n  \n  # remove duplicates\n  result <- result[!duplicated(result$gene), ]\n  \n  # return the results\n  return(result)\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDegree_Distribution_Comparison <- function(data1, data2){\n  \n  # load the necessary library for the plot\n  library(ggplot2)\n  \n  # calculate degree counts for each database\n  degree_distribution_1 <- Degree_Distribution(data1)\n  degree_distribution_2 <- Degree_Distribution(data2)\n  \n  # create dataframe for creating comparison plot\n  df <- rbind(data.frame(degree_distribution_1, dataset = deparse(substitute(data1))),\n              data.frame(degree_distribution_2, dataset = deparse(substitute(data2))))\n  \n  # create histogram plot with ggplot\n  ggplot(df, aes(x=degree, y=after_stat(count), fill=dataset)) +\n    # display a histogram\n    geom_histogram(position=\"dodge\", alpha=0.5) +\n    # customize legends\n    labs(x=\"Degree\", \n         y=\"Number of Nodes\", \n         title=\"Comparison of Degree Distributions\",\n         fill=expression(underline(\"Dataset\"))) +\n    # specify legend display\n    guides(color=\"none\") +\n    # customize text elements\n    theme(strip.text.x=element_text(size=8),\n          plot.title=element_text(size=12, hjust=0.5, face=\"bold\"),\n          legend.title=element_text(size=10))\n  \n}\n```\n:::\n\n\n## Percentage of overall identity of the graph at degree 1 \n\n\n::: {.cell}\n\n```{.r .cell-code}\nGlobal_Identity <- function(data1, data2) {\n  \n  # check if data1 or data2 is empty\n  if (nrow(data1) == 0) {\n    return(list(\n      identity_percentage_ReferenceData1 = \"NO NODE\",\n      identity_percentage_ReferenceData2 = \"/\"\n    ))\n  }\n  if (nrow(data2) == 0) {\n    return(list(\n      identity_percentage_ReferenceData1 = \"/\",\n      identity_percentage_ReferenceData2 = \"NO NODE\"\n    ))\n  }\n  \n  # sort gene pairs in both datasets\n  data1 <- Sort_Columns(data1)\n  data2 <- Sort_Columns(data2)\n  \n  # concatenate gene pairs into a new dataframe for each dataset\n  gene_pairs_data1 <- cbind(from = data1$from, to = data1$to, pairs = paste(data1$from, data1$to, sep = \"_\"))\n  gene_pairs_data2 <- cbind(from = data2$from, to = data2$to, pairs = paste(data2$from, data2$to, sep = \"_\"))\n  \n  # remove duplicates in gene pairs\n  unique_pairs_data1 <- unique(gene_pairs_data1)\n  unique_pairs_data2 <- unique(gene_pairs_data2)\n  \n  # identify different gene pairs in each dataset\n  different_pairs_data1 <- setdiff(unique_pairs_data2[, 3], unique_pairs_data1[, 3])\n  different_pairs_data2 <- setdiff(unique_pairs_data1[, 3], unique_pairs_data2[, 3])\n  \n  # calculate the number of identical gene pairs in each dataset\n  num_identical_pairs_data1 <- length(unique_pairs_data2[, 3]) - length(different_pairs_data1)\n  num_identical_pairs_data2 <- length(unique_pairs_data1[, 3]) - length(different_pairs_data2)\n  \n  # calculate the percentage of identical gene pairs compared to the total number of unique pairs\n  identity_percentage_ReferenceData1 <- (num_identical_pairs_data1 / length(unique_pairs_data1[, 3])) * 100\n  identity_percentage_ReferenceData2 <- (num_identical_pairs_data2 / length(unique_pairs_data2[, 3])) * 100\n  \n  # construct the final report as a list\n  report <- list(\n    identity_percentage_ReferenceData1 = identity_percentage_ReferenceData1,\n    identity_percentage_ReferenceData2 = identity_percentage_ReferenceData2\n  )\n  \n  # return the results\n  return(report)\n  \n}\n```\n:::\n\n\n## Percentage of identity between two graphs as a function of node degree \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDegree_VS_IdentityPercentage <- function(data1, data2){\n  \n  # determine the maximum degree\n  n <- max(Degree_Distribution(data1)$degree, Degree_Distribution(data2)$degree)\n  \n  # create a dataframe to store identity percentages\n  identity_percentages <- data.frame(degree = 1:n,\n                                     ReferenceData1 = numeric(n),\n                                     ReferenceData2 = numeric(n))\n  # initialize columns for data references\n  identity_percentages$ReferenceData1 <- 1\n  identity_percentages$ReferenceData2 <- 1\n  \n  # iterate over each degree\n  for (i in 1:n){\n    # extract genes lists for each dataset based on degree\n    genes_list_data1 <- Degree_Distribution(data1)$gene[Degree_Distribution(data1)$degree == i]\n    genes_list_data2 <- Degree_Distribution(data2)$gene[Degree_Distribution(data2)$degree == i]\n    \n    # initialize dataframes to store gene pairs\n    all_gene_pairs_data1 <- data.frame(from = character(), to = character())\n    all_gene_pairs_data2 <- data.frame(from = character(), to = character())\n    \n    # iterate over genes in each list\n    for (gene in genes_list_data1) {\n      # select rows where the gene is in the \"from\" or \"to\" column\n      gene_pairs_data1 <- data1[data1$from == gene | data1$to == gene, c(\"from\", \"to\")]\n      # append gene pairs to all_gene_pairs_data1\n      all_gene_pairs_data1 <- rbind(all_gene_pairs_data1, gene_pairs_data1)\n    }\n    for (gene in genes_list_data2) {\n      gene_pairs_data2 <- data2[data2$from == gene | data2$to == gene, c(\"from\", \"to\")]\n      all_gene_pairs_data2 <- rbind(all_gene_pairs_data2, gene_pairs_data2)\n    }\n    \n    # remove duplicate gene pairs\n    all_gene_pairs_data1 <- unique(all_gene_pairs_data1)\n    all_gene_pairs_data2 <- unique(all_gene_pairs_data2)\n    \n    # calculate identity percentages and store in the dataframe\n    identity_percentages$ReferenceData1[i] <- Global_Identity(all_gene_pairs_data1, all_gene_pairs_data2)$identity_percentage_ReferenceData1\n    identity_percentages$ReferenceData2[i] <- Global_Identity(all_gene_pairs_data1, all_gene_pairs_data2)$identity_percentage_ReferenceData2\n  }\n  \n  # create a dataframe for the graph\n  graph <- data.frame(degree = identity_percentages$degree,\n                      percentages = c(identity_percentages$ReferenceData1,\n                                      identity_percentages$ReferenceData2),\n                      reference = c(rep(deparse(substitute(data1)), length(identity_percentages$ReferenceData1)),\n                                    rep(deparse(substitute(data2)), length(identity_percentages$ReferenceData2))))\n  \n  # modify the values for red points and NA values to 0\n  graph$percentages[graph$percentages %in% c(\"NO NODE\", \"/\")] <- NA\n  graph$color <- ifelse(is.na(graph$percentages), \"Absent degree\", as.character(graph$reference))\n  graph$percentages[graph$percentages %in% NA] <- 0\n  \n  # create the plot\n  library(ggplot2)\n  plot <- ggplot(graph, aes(x = degree, y = as.numeric(percentages), fill = reference, color = color)) +\n    # display a scatterplot\n    geom_point() +\n    # customize legends\n    labs(x = \"Degree\", \n         y = \"Identity Percentage\", \n         title = \"Degree vs Identity Distributions\",\n         color = expression(underline(\"Reference\"))) +\n    # specify legend display\n    guides(fill = \"none\") +\n    # customize text elements\n    theme(strip.text.x = element_text(size = 8),\n          plot.title = element_text(size = 12, hjust = 0.5, face = \"bold\"),\n          legend.title = element_text(size = 10))\n  \n  # display the plot\n  print(plot)\n  \n  # return the dataframe with the results\n  return(identity_percentages)\n  \n}\n```\n:::\n\n\n## \n\n\n::: {.cell}\n\n```{.r .cell-code}\nGlobal_Identity_Degree <- function(data1, data2, degree) {\n  \n  # convert dataframes to graphs\n  graph_data1 <- Dataframe_To_Graph(data1)\n  graph_data2 <- Dataframe_To_Graph(data2)\n  \n  # initialize variables to store paths\n  paths_data1 <- c()\n  paths_data2 <- c()\n  \n  # find all simple paths in each graph up to a given degree\n  l_data1 <- unlist(lapply(V(graph_data1) , function(x) all_simple_paths(graph_data1, from=x, cutoff=degree)), recursive = FALSE)\n  l_data2 <- unlist(lapply(V(graph_data2) , function(x) all_simple_paths(graph_data2, from=x, cutoff=degree)), recursive = FALSE)\n  \n  # filter paths to only include those with the specified degree\n  l_data1 <- l_data1[lengths(l_data1) == degree + 1]\n  l_data2 <- l_data2[lengths(l_data2) == degree + 1]\n  \n  # convert paths to character IDs\n  paths_data1 <- lapply(1:length(l_data1), function(x) as_ids(l_data1[[x]]))\n  paths_data2 <- lapply(1:length(l_data2), function(x) as_ids(l_data2[[x]]))\n  \n  # combine paths into dataframes\n  paths_data1 <- do.call(rbind, paths_data1)\n  paths_data2 <- do.call(rbind, paths_data2)\n  \n  # combine paths and create a new column by uniting the paths\n  paths_data1 <- data.frame(c(paths_data1, unite(paths_data1, paths, sep=\"_\")))\n  paths_data2 <- data.frame(c(paths_data2, unite(paths_data2, paths, sep=\"_\")))\n  \n  # identify different gene pairs in each dataset\n  different_pairs_data1 <- setdiff(paths_data2[,degree+2], paths_data1[,degree+2])\n  different_pairs_data2 <- setdiff(paths_data1[,degree+2], paths_data2[,degree+2])\n  \n  # calculate the number of identical gene pairs in each dataset\n  num_identical_pairs_data1 <- length(paths_data2[,degree+1]) - length(different_pairs_data1)\n  num_identical_pairs_data2 <- length(paths_data1[,degree+1]) - length(different_pairs_data2)\n  \n  # calculate the percentage of identical gene pairs compared to the total number of unique pairs\n  identity_percentage_ReferenceData1 <- (num_identical_pairs_data1 / length(paths_data1[,degree+1])) * 100\n  identity_percentage_ReferenceData2 <- (num_identical_pairs_data2 / length(paths_data2[,degree+1])) * 100\n  \n  # construct the final report as a list\n  report <- list(\n    identity_percentage_ReferenceData1 = identity_percentage_ReferenceData1,\n    identity_percentage_ReferenceData2 = identity_percentage_ReferenceData2\n  )\n  \n  # return the results\n  return(report)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDegree_Identity_Comparison <- function(data1, data2, n) {\n  \n  # convert dataframes to graphs\n  graph_data1 <- Dataframe_To_Graph(data1)\n  graph_data2 <- Dataframe_To_Graph(data2)\n  \n  # find all simple paths in each graph up to the specified degree\n  l_data1 <- unlist(lapply(V(graph_data1) , function(x) all_simple_paths(graph_data1, from=x, cutoff=n)), recursive = FALSE)\n  l_data2 <- unlist(lapply(V(graph_data2) , function(x) all_simple_paths(graph_data2, from=x, cutoff=n)), recursive = FALSE)\n  \n  # calculate the length of each path\n  lengths_paths_data1 <- sapply(l_data1, length)\n  lengths_paths_data2 <- sapply(l_data2, length)\n  \n  # find the maximum path length\n  longueur_max_data1 <- max(lengths_paths_data1)\n  longueur_max_data2 <- max(lengths_paths_data2)\n  \n  # determine the maximum degree to consider\n  n <- min(longueur_max_data1, longueur_max_data2) - 1\n  \n  # initialize dataframe to store identity percentages\n  graph <- data.frame(identity_percentage_ReferenceData1 = numeric(n),\n                      identity_percentage_ReferenceData2 = numeric(n))\n  \n  # loop over degrees and calculate identity percentages\n  for (i in 1:n){\n    # calculate identity percentages only if they are not equal to 0\n    if (Global_Identity_Degree(data1,data2,i)$identity_percentage_ReferenceData1 != 0 ||\n        Global_Identity_Degree(data1,data2,i)$identity_percentage_ReferenceData2 != 0) {\n      graph$identity_percentage_ReferenceData1[i] <- Global_Identity_Degree(data1,data2,i)$identity_percentage_ReferenceData1\n      graph$identity_percentage_ReferenceData2[i] <- Global_Identity_Degree(data1,data2,i)$identity_percentage_ReferenceData2\n    }\n  }\n  \n  # create a dataframe for the graph\n  df <- data.frame(length = seq(1,n),\n                   percentages = c(graph$identity_percentage_ReferenceData1,\n                                   graph$identity_percentage_ReferenceData2),\n                   reference = c(rep(deparse(substitute(data1)), length(graph$identity_percentage_ReferenceData1)),\n                                 rep(deparse(substitute(data2)), length(graph$identity_percentage_ReferenceData2))))\n  \n  # create the plot\n  library(ggplot2)\n  plot <- ggplot(df, aes(x = length, y = as.numeric(percentages), color = reference)) +\n    # display a scatterplot\n    geom_point() +\n    # customize legends\n    labs(x = \"Length of Paths\", \n         y = \"Identity Percentage\", \n         title = \"Length of Paths vs Identity Percentages\",\n         color = expression(underline(\"Reference\"))) +\n    # customize scales\n    scale_x_continuous(breaks=c(seq(1, n, by = 1))) +\n    # customize text elements\n    theme(strip.text.x = element_text(size = 8),\n          plot.title = element_text(size = 12, hjust = 0.5, face = \"bold\"),\n          legend.title = element_text(size = 10))\n  \n  # print the plot\n  print(plot)\n  \n  # return the dataframe with the results\n  return(graph)\n}\n```\n:::\n\n\n\n# Display of results\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}